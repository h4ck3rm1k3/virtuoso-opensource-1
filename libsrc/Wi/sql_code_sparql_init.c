/* This file is automatically generated by sql_to_c.awk */

#include "sqlnode.h"
#include "sqlfn.h"
#include "sqltype.h"

/* useraggr.sql */

static const char *proc0 = 
"#line 24 \"[executable]/useraggr.sql\"\n"
" create procedure STD_COUNT (in _env varchar)\n"
"{\n"
"return aref (deserialize(_env), 0);\n"
"}\n"
"--src useraggr.sql:22\n";

static const char *proc1 = 
"#line 31 \"[executable]/useraggr.sql\"\n"
" create procedure STD11_INIT (inout _env varchar)\n"
"{\n"
"_env := serialize (vector (0, 0.0));\n"
"}\n"
"--src useraggr.sql:29\n";

static const char *proc2 = 
"#line 38 \"[executable]/useraggr.sql\"\n"
" create procedure STD12_INIT (inout _env varchar)\n"
"{\n"
"_env := serialize (vector (0, 0.0,0.0));\n"
"}\n"
"--src useraggr.sql:36\n";

static const char *proc3 = 
"#line 45 \"[executable]/useraggr.sql\"\n"
" create procedure STD13_INIT (inout _env varchar)\n"
"{\n"
"_env := serialize (vector (0, 0.0,0.0, 0.0));\n"
"}\n"
"--src useraggr.sql:43\n";

static const char *proc4 = 
"#line 52 \"[executable]/useraggr.sql\"\n"
" create procedure VAR_ACC (inout _env varchar, in val numeric)\n"
"{\n"
"if (_env is null)\n"
"return;\n"
"if (val is null)\n"
"return;\n"
"declare ctx any;\n"
"ctx := deserialize (_env);\n"
"\n"
"aset( ctx, 1, aref (ctx, 1) + val);\n"
"aset( ctx, 2, aref (ctx, 2) + val*val);\n"
"aset( ctx, 0, aref (ctx, 0) + 1);\n"
"_env := serialize (ctx);\n"
"}\n"
"--src useraggr.sql:50\n";

static const char *proc5 = 
"#line 69 \"[executable]/useraggr.sql\"\n"
" create procedure VAR_POP_FIN (inout _ctx varchar)\n"
"{\n"
"if (_ctx is null)\n"
"return null;\n"
"declare _env any;\n"
"_env := deserialize (_ctx);\n"
"declare c integer;\n"
"c := aref (_env, 0);\n"
"if (c = 0)\n"
"return null;\n"
"return  (aref (_env, 2) - aref (_env, 1) * aref (_env, 1) / c) / c;\n"
"}\n"
"--src useraggr.sql:67\n";

static const char *proc6 = 
"#line 84 \"[executable]/useraggr.sql\"\n"
" create procedure VAR_SAMP_FIN (inout _ctx varchar)\n"
"{\n"
"if (_ctx is null)\n"
"return null;\n"
"declare _env any;\n"
"_env := deserialize (_ctx);\n"
"declare c integer;\n"
"c := aref (_env, 0);\n"
"if (c = 0)\n"
"return null;\n"
"if (c = 1)\n"
"return 0.0;\n"
"return  (aref (_env, 2) - aref (_env, 1) * aref (_env, 1) / c) / (c - 1);\n"
"}\n"
"--src useraggr.sql:82\n";

static const char *proc7 = 
"#line 101 \"[executable]/useraggr.sql\"\n"
" create procedure VAR_FIN (inout _ctx varchar)\n"
"{\n"
"if (_ctx is null)\n"
"return null;\n"
"if (STD_COUNT (_ctx) = 1)\n"
"return null;\n"
"return VAR_SAMP_FIN (_ctx);\n"
"}\n"
"--src useraggr.sql:99\n";

static const char *proc8 = 
"#line 112 \"[executable]/useraggr.sql\"\n"
" create procedure STDDEV_POP_FIN (inout _ctx varchar)\n"
"{\n"
"if (_ctx is null)\n"
"return null;\n"
"declare c integer;\n"
"declare _env any;\n"
"_env := deserialize (_ctx);\n"
"c := aref (_env, 0);\n"
"if (c = 0)\n"
"return null;\n"
"\n"
"return  sqrt ((aref (_env, 2) - aref (_env, 1) * aref (_env, 1) / c) / c) ;\n"
"}\n"
"--src useraggr.sql:110\n";

static const char *proc9 = 
"#line 128 \"[executable]/useraggr.sql\"\n"
" create procedure STDDEV_SAMP_FIN (inout _ctx varchar)\n"
"{\n"
"if (_ctx is null)\n"
"return null;\n"
"declare c integer;\n"
"declare _env any;\n"
"_env := deserialize (_ctx);\n"
"c := aref (_env, 0);\n"
"if (c = 0)\n"
"return null;\n"
"if (c = 1)\n"
"return 0.0;\n"
"return  sqrt ((aref (_env, 2) - aref (_env, 1) * aref (_env, 1) / c) / ( c - 1));\n"
"}\n"
"--src useraggr.sql:126\n";

static const char *proc10 = 
"#line 145 \"[executable]/useraggr.sql\"\n"
" create procedure STDDEV_FIN (inout _ctx varchar)\n"
"{\n"
"if (_ctx is null)\n"
"return null;\n"
"if (STD_COUNT (_ctx) = 1)\n"
"return null;\n"
"return STDDEV_SAMP_FIN (_ctx);\n"
"}\n"
"--src useraggr.sql:143\n";

static const char *proc11 = 
"#line 156 \"[executable]/useraggr.sql\"\n"
" create procedure COVAR_ACC (inout _ctx any,\n"
"in expr1 numeric,\n"
"in expr2 numeric)\n"
"{\n"
"if (_ctx is null)\n"
"return;\n"
"if (expr1 is null or expr2 is null)\n"
"return;\n"
"\n"
"declare _env any;\n"
"\n"
"_env := deserialize (_ctx);\n"
"\n"
"aset (_env, 1, aref (_env,1)+expr1);\n"
"aset (_env, 2, aref (_env,2)+expr2);\n"
"aset (_env, 3, aref (_env,3)+expr2*expr1);\n"
"aset (_env, 0, aref (_env,0)+1);\n"
"\n"
"_ctx := serialize (_env);\n"
"}\n"
"--src useraggr.sql:154\n";

static const char *proc12 = 
"#line 179 \"[executable]/useraggr.sql\"\n"
" create procedure COVAR_SAMP_FIN (inout _ctx any)\n"
"{\n"
"if (_ctx is null)\n"
"return null;\n"
"declare _env any;\n"
"_env := deserialize (_ctx);\n"
"if (aref (_env, 0) = 0)\n"
"return null;\n"
"if (aref (_env, 0) = 1)\n"
"return 0.0;\n"
"\n"
"return (aref (_env, 3) - aref(_env,2) * aref (_env,1) / aref (_env, 0)) / ( aref (_env, 0) - 1);\n"
"}\n"
"--src useraggr.sql:177\n";

static const char *proc13 = 
"#line 195 \"[executable]/useraggr.sql\"\n"
" create procedure COVAR_POP_FIN (inout _ctx any)\n"
"{\n"
"if (_ctx is null)\n"
"return null;\n"
"declare _env any;\n"
"_env := deserialize (_ctx);\n"
"if (aref (_env, 0) = 0)\n"
"return null;\n"
"if (aref (_env, 0) = 1)\n"
"return 0.0;\n"
"\n"
"return (aref (_env, 3) - aref(_env,2) * aref (_env,1) / aref (_env, 0))/ aref (_env,0);\n"
"}\n"
"--src useraggr.sql:193\n";

static const char *proc14 = 
"#line 211 \"[executable]/useraggr.sql\"\n"
" create procedure COVAR_FIN (inout _ctx varchar)\n"
"{\n"
"if (_ctx is null)\n"
"return null;\n"
"if (STD_COUNT (_ctx) = 1)\n"
"return null;\n"
"return COVAR_SAMP_FIN (_ctx);\n"
"}\n"
"--src useraggr.sql:209\n";

static const char *other0 = 
"create aggregate DB.DBA.VAR_POP (in val numeric) returns numeric from\n"
"STD12_INIT, VAR_ACC, VAR_POP_FIN\n";

static const char *other1 = 
"create aggregate DB.DBA.VAR_SAMP (in val numeric) returns numeric from\n"
"STD12_INIT, VAR_ACC, VAR_SAMP_FIN\n";

static const char *other2 = 
"create aggregate DB.DBA.VAR (in val numeric) returns numeric from\n"
"STD12_INIT, VAR_ACC, VAR_FIN\n";

static const char *other3 = 
"create aggregate DB.DBA.STDDEV_POP (in val numeric) returns numeric from\n"
"STD12_INIT, VAR_ACC, STDDEV_POP_FIN\n";

static const char *other4 = 
"create aggregate DB.DBA.STDDEV_SAMP (in val numeric) returns numeric from\n"
"STD12_INIT, VAR_ACC, STDDEV_SAMP_FIN\n";

static const char *other5 = 
"create aggregate DB.DBA.STDDEV (in val numeric) returns numeric from\n"
"STD12_INIT, VAR_ACC, STDDEV_FIN\n";

static const char *other6 = 
"create aggregate DB.DBA.COVAR_SAMP (in expr1 numeric, in expr2 numeric) returns numeric from\n"
"STD13_INIT, COVAR_ACC, COVAR_SAMP_FIN\n";

static const char *other7 = 
"create aggregate DB.DBA.COVAR_POP (in expr1 numeric, in expr2 numeric) returns numeric from\n"
"STD13_INIT, COVAR_ACC, COVAR_POP_FIN\n";

static const char *other8 = 
"create aggregate DB.DBA.COVAR (in expr1 numeric, in expr2 numeric) returns numeric from\n"
"STD13_INIT, COVAR_ACC, COVAR_FIN\n";

static const char *proc15 = 
"#line 250 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_SLOPE_INIT (inout _env varchar)\n"
"{\n"
"declare _ctx1 varchar;\n"
"declare _ctx2 varchar;\n"
"\n"
"STD13_INIT (_ctx1);\n"
"STD12_INIT (_ctx2);\n"
"\n"
"_env := serialize (vector (0, _ctx1, _ctx2));\n"
"}\n"
"--src useraggr.sql:248\n";

static const char *proc16 = 
"#line 263 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_SLOPE_ACC (inout _env varchar, in expr1 numeric, in expr2 numeric)\n"
"{\n"
"if (_env is null)\n"
"return;\n"
"if ( (expr1 is null) or (expr2 is null))\n"
"return;\n"
"declare _ctx any;\n"
"_ctx := deserialize (_env);\n"
"\n"
"declare _ctx1 varchar;\n"
"declare _ctx2 varchar;\n"
"\n"
"_ctx1 := aref (_ctx, 1);\n"
"_ctx2 := aref (_ctx, 2);\n"
"\n"
"aset (_ctx, 0, aref (_ctx,0) + 1);\n"
"COVAR_ACC (_ctx1, expr1, expr2);\n"
"VAR_ACC (_ctx2, expr2);\n"
"\n"
"aset (_ctx, 1, _ctx1);\n"
"aset (_ctx, 2, _ctx2);\n"
"\n"
"_env := serialize (_ctx);\n"
"}\n"
"--src useraggr.sql:261\n";

static const char *proc17 = 
"#line 290 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_SLOPE_FIN (inout _env varchar)\n"
"{\n"
"if (_env is null)\n"
"return null;\n"
"declare _ctx any;\n"
"declare c integer;\n"
"\n"
"_ctx := deserialize (_env);\n"
"\n"
"c := aref (_ctx, 0);\n"
"if (c = 0)\n"
"return 0;\n"
"if (c = 1)\n"
"return null;\n"
"\n"
"declare _ctx1 varchar;\n"
"declare _ctx2 varchar;\n"
"declare covar_pop_val numeric;\n"
"declare var_pop_val numeric;\n"
"\n"
"_ctx1 := aref (_ctx, 1);\n"
"_ctx2 := aref (_ctx, 2);\n"
"\n"
"\n"
"covar_pop_val := COVAR_POP_FIN (_ctx1);\n"
"var_pop_val := VAR_POP_FIN (_ctx2);\n"
"\n"
"if (var_pop_val = 0)\n"
"return null;\n"
"return covar_pop_val / var_pop_val;\n"
"}\n"
"--src useraggr.sql:288\n";

static const char *other9 = 
"create aggregate DB.DBA.REGR_SLOPE (in expr1 numeric, in expr2 numeric) returns numeric from REGR_SLOPE_INIT, REGR_SLOPE_ACC, REGR_SLOPE_FIN\n";

static const char *proc18 = 
"#line 327 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_INTERCEPT_INIT (inout _env varchar)\n"
"{\n"
"declare _ctx_regr_slope varchar;\n"
"\n"
"REGR_SLOPE_INIT (_ctx_regr_slope);\n"
"_env := serialize (vector (0, 0.0, 0.0, _ctx_regr_slope));\n"
"}\n"
"--src useraggr.sql:325\n";

static const char *proc19 = 
"#line 337 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_INTERCEPT_ACC (inout _env varchar, in expr1 numeric, in expr2 numeric)\n"
"{\n"
"if (_env is null)\n"
"return;\n"
"if ((expr1 is null) or (expr2 is null))\n"
"return;\n"
"\n"
"declare _ctx any;\n"
"_ctx := deserialize (_env);\n"
"\n"
"aset (_ctx, 0, aref (_ctx, 0) + 1);\n"
"aset (_ctx, 1, aref (_ctx, 1) + expr1);\n"
"aset (_ctx, 2, aref (_ctx, 2) + expr2);\n"
"\n"
"declare _ctx_r varchar;\n"
"_ctx_r := aref (_ctx, 3);\n"
"REGR_SLOPE_ACC (_ctx_r, expr1, expr2);\n"
"aset (_ctx, 3, _ctx_r);\n"
"\n"
"_env := serialize (_ctx);\n"
"}\n"
"--src useraggr.sql:335\n";

static const char *proc20 = 
"#line 361 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_INTERCEPT_FIN (inout _env varchar)\n"
"{\n"
"if (_env is null)\n"
"return null;\n"
"declare _ctx any;\n"
"_ctx := deserialize (_env);\n"
"declare c integer;\n"
"c := aref (_ctx, 0);\n"
"if ((c = 0) or (c = 1))\n"
"return null;\n"
"\n"
"return aref (_ctx, 1) / c - REGR_SLOPE_FIN (aref (_ctx, 3)) * aref (_ctx, 2) / c;\n"
"}\n"
"--src useraggr.sql:359\n";

static const char *other10 = 
"create aggregate DB.DBA.REGR_INTERCEPT (in expr1 numeric, in expr2 numeric) returns numeric from REGR_INTERCEPT_INIT, REGR_INTERCEPT_ACC, REGR_INTERCEPT_FIN\n";

static const char *proc21 = 
"#line 380 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_COUNT_INIT (inout _env integer)\n"
"{\n"
"_env := 0;\n"
"}\n"
"--src useraggr.sql:378\n";

static const char *proc22 = 
"#line 387 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_COUNT_ACC (inout _env integer, in expr numeric, in expr2 numeric)\n"
"{\n"
"if ((_env is null) or (expr is null) or (expr2 is null))\n"
"return;\n"
"_env := _env + 1;\n"
"}\n"
"--src useraggr.sql:385\n";

static const char *proc23 = 
"#line 396 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_COUNT_FIN (inout _env integer)\n"
"{\n"
"return _env;\n"
"}\n"
"--src useraggr.sql:394\n";

static const char *proc24 = 
"#line 403 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_COUNT_MERGE (inout _e1 integer, inout _e2 integer)\n"
"{\n"
"_e1 := _e1 + _e2;\n"
"}\n"
"--src useraggr.sql:401\n";

static const char *other11 = 
"create aggregate DB.DBA.REGR_COUNT (in expr1 numeric, in expr2 numeric) returns numeric from REGR_COUNT_INIT, REGR_COUNT_ACC, REGR_COUNT_FIN, REGR_COUNT_MERGE\n";

static const char *proc25 = 
"#line 413 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_AVG_ACC (inout _env varchar, in expr1 numeric, in expr2 numeric)\n"
"{\n"
"if (_env is null)\n"
"return;\n"
"\n"
"if ( (expr1 is null) or (expr2 is null))\n"
"return;\n"
"declare _ctx any;\n"
"_ctx := deserialize (_env);\n"
"\n"
"aset (_ctx, 0, aref (_ctx, 0) + 1);\n"
"aset (_ctx, 1, aref (_ctx, 1) + expr1);\n"
"aset (_ctx, 2, aref (_ctx, 2) + expr2);\n"
"\n"
"_env := serialize (_ctx);\n"
"}\n"
"--src useraggr.sql:411\n";

static const char *proc26 = 
"#line 432 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_AVGX_FIN (inout _env varchar)\n"
"{\n"
"if (_env is null)\n"
"return null;\n"
"declare _ctx any;\n"
"_ctx := deserialize (_env);\n"
"if (aref (_ctx, 0) = 0)\n"
"return null;\n"
"return aref (_ctx, 1) / aref (_ctx,0);\n"
"}\n"
"--src useraggr.sql:430\n";

static const char *proc27 = 
"#line 445 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_AVGY_FIN (inout _env varchar)\n"
"{\n"
"if (_env is null)\n"
"return null;\n"
"declare _ctx any;\n"
"_ctx := deserialize (_env);\n"
"if (aref (_ctx, 0) = 0)\n"
"return null;\n"
"return aref (_ctx, 2) / aref (_ctx,0);\n"
"}\n"
"--src useraggr.sql:443\n";

static const char *other12 = 
"create aggregate DB.DBA.REGR_AVGX (in x numeric, in y numeric) returns numeric from\n"
"STD12_INIT, REGR_AVG_ACC, REGR_AVGX_FIN\n";

static const char *other13 = 
"create aggregate DB.DBA.REGR_AVGY (in x numeric, in y numeric) returns numeric from\n"
"STD12_INIT, REGR_AVG_ACC, REGR_AVGY_FIN\n";

static const char *proc28 = 
"#line 466 \"[executable]/useraggr.sql\"\n"
" create procedure CORR_INIT (inout _env varchar)\n"
"{\n"
"declare _ctx_cov varchar;\n"
"declare _ctx_stdev1 varchar;\n"
"declare _ctx_stdev2 varchar;\n"
"\n"
"STD13_INIT (_ctx_cov);\n"
"STD12_INIT (_ctx_stdev1);\n"
"STD12_INIT (_ctx_stdev2);\n"
"\n"
"_env := serialize (vector (0, _ctx_cov, _ctx_stdev1, _ctx_stdev2));\n"
"}\n"
"--src useraggr.sql:464\n";

static const char *proc29 = 
"#line 481 \"[executable]/useraggr.sql\"\n"
" create procedure CORR_ACC (inout _env varchar, in e1 numeric, in e2 numeric)\n"
"{\n"
"if (_env is null)\n"
"return;\n"
"if ((e1 is null) or (e2 is null))\n"
"return;\n"
"declare _ctx any;\n"
"_ctx := deserialize (_env);\n"
"\n"
"declare _ctx_cov varchar;\n"
"declare _ctx_stdev1 varchar;\n"
"declare _ctx_stdev2 varchar;\n"
"\n"
"_ctx_cov := aref (_ctx, 1);\n"
"_ctx_stdev1 := aref (_ctx, 2);\n"
"_ctx_stdev2 := aref (_ctx, 3);\n"
"\n"
"COVAR_ACC (_ctx_cov, e1, e2);\n"
"VAR_ACC (_ctx_stdev1, e1);\n"
"VAR_ACC (_ctx_stdev2, e2);\n"
"\n"
"aset (_ctx, 0, aref (_ctx, 0) + 1);\n"
"aset (_ctx, 1, _ctx_cov);\n"
"aset (_ctx, 2, _ctx_stdev1);\n"
"aset (_ctx, 3, _ctx_stdev2);\n"
"\n"
"_env := serialize (_ctx);\n"
"}\n"
"--src useraggr.sql:479\n";

static const char *proc30 = 
"#line 512 \"[executable]/useraggr.sql\"\n"
" create procedure CORR_FIN (inout _env varchar)\n"
"{\n"
"if (_env is null)\n"
"return null;\n"
"declare _ctx any;\n"
"_ctx := deserialize (_env);\n"
"\n"
"declare _ctx_cov_val numeric;\n"
"declare _ctx_stdev1_val numeric;\n"
"declare _ctx_stdev2_val numeric;\n"
"\n"
"_ctx_cov_val := COVAR_POP_FIN (aref (_ctx, 1));\n"
"_ctx_stdev1_val := STDDEV_POP_FIN (aref (_ctx, 2));\n"
"_ctx_stdev2_val := STDDEV_POP_FIN (aref (_ctx, 3));\n"
"\n"
"if (_ctx_cov_val is null)\n"
"return null;\n"
"if (_ctx_stdev1_val is null or _ctx_stdev1_val = 0)\n"
"return null;\n"
"if (_ctx_stdev2_val is null or _ctx_stdev2_val = 0)\n"
"return null;\n"
"\n"
"return _ctx_cov_val / _ctx_stdev1_val / _ctx_stdev2_val;\n"
"}\n"
"--src useraggr.sql:510\n";

static const char *other14 = 
"create aggregate DB.DBA.CORR (in x numeric, in y numeric) returns numeric from\n"
"CORR_INIT, CORR_ACC, CORR_FIN\n";

static const char *proc31 = 
"#line 543 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_R2_INIT (inout _env varchar)\n"
"{\n"
"declare _ctx_vp1 varchar;\n"
"declare _ctx_vp2 varchar;\n"
"declare _ctx_corr varchar;\n"
"\n"
"STD12_INIT (_ctx_vp1);\n"
"STD12_INIT (_ctx_vp2);\n"
"CORR_INIT (_ctx_corr);\n"
"\n"
"_env := serialize (vector (_ctx_vp1, _ctx_vp2, _ctx_corr));\n"
"}\n"
"--src useraggr.sql:541\n";

static const char *proc32 = 
"#line 558 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_R2_ACC (inout _env varchar, in e1 numeric, in e2 numeric)\n"
"{\n"
"if (_env is null)\n"
"return;\n"
"if (e1 is null or e2 is null)\n"
"return;\n"
"declare _ctx  any;\n"
"\n"
"_ctx := deserialize (_env);\n"
"\n"
"declare _ctx_vp1 varchar;\n"
"declare _ctx_vp2 varchar;\n"
"declare _ctx_corr varchar;\n"
"\n"
"_ctx_vp1 := aref (_ctx, 0);\n"
"_ctx_vp2 := aref (_ctx, 1);\n"
"_ctx_corr := aref (_ctx, 2);\n"
"\n"
"VAR_ACC (_ctx_vp1, e1);\n"
"VAR_ACC (_ctx_vp2, e2);\n"
"CORR_ACC (_ctx_corr, e1, e2);\n"
"\n"
"aset (_ctx, 0, _ctx_vp1);\n"
"aset (_ctx, 1, _ctx_vp2);\n"
"aset (_ctx, 2, _ctx_corr);\n"
"\n"
"_env := serialize (_ctx);\n"
"}\n"
"--src useraggr.sql:556\n";

static const char *proc33 = 
"#line 589 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_R2_FIN (inout _env varchar)\n"
"{\n"
"if (_env is null)\n"
"return null;\n"
"declare _ctx any;\n"
"\n"
"_ctx := deserialize (_env);\n"
"\n"
"declare _vp1 numeric;\n"
"declare _vp2 numeric;\n"
"declare _corr numeric;\n"
"\n"
"_vp2 := VAR_POP_FIN (aref(_ctx, 1));\n"
"if (_vp2 is null or _vp2 = 0)\n"
"return null;\n"
"_vp1 := VAR_POP_FIN (aref(_ctx, 0));\n"
"if (_vp1 is null or _vp1 = 0)\n"
"return 1;\n"
"_corr := CORR_FIN (aref (_ctx, 2));\n"
"return _corr * _corr;\n"
"}\n"
"--src useraggr.sql:587\n";

static const char *other15 = 
"create aggregate DB.DBA.REGR_R2 (in e1 numeric, in e2 numeric) returns numeric from\n"
"REGR_R2_INIT, REGR_R2_ACC, REGR_R2_FIN\n";

static const char *proc34 = 
"#line 617 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_SXX_ACC (inout _env varchar, in e1 numeric, in e2 numeric)\n"
"{\n"
"if (_env is null)\n"
"return;\n"
"if (e1 is null or e2 is null)\n"
"return;\n"
"\n"
"VAR_ACC (_env, e2);\n"
"}\n"
"--src useraggr.sql:615\n";

static const char *proc35 = 
"#line 629 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_SYY_ACC (inout _env varchar, in e1 numeric, in e2 numeric)\n"
"{\n"
"if (_env is null)\n"
"return;\n"
"if (e1 is null or e2 is null)\n"
"return;\n"
"\n"
"VAR_ACC (_env, e1);\n"
"}\n"
"--src useraggr.sql:627\n";

static const char *proc36 = 
"#line 641 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_SXY_ACC (inout _env varchar, in e1 numeric, in e2 numeric)\n"
"{\n"
"if (_env is null)\n"
"return;\n"
"if (e1 is null or e2 is null)\n"
"return;\n"
"\n"
"COVAR_ACC (_env, e1, e2);\n"
"}\n"
"--src useraggr.sql:639\n";

static const char *proc37 = 
"#line 653 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_S___FIN (inout _env varchar)\n"
"{\n"
"if (_env is null)\n"
"return null;\n"
"declare _ctx any;\n"
"_ctx := deserialize (_env);\n"
"\n"
"declare _var numeric;\n"
"\n"
"_var := VAR_POP_FIN (_env);\n"
"if (_var is null)\n"
"return null;\n"
"return aref (_ctx,0) * _var;\n"
"}\n"
"--src useraggr.sql:651\n";

static const char *proc38 = 
"#line 670 \"[executable]/useraggr.sql\"\n"
" create procedure REGR_SXY_FIN (inout _env varchar)\n"
"{\n"
"if (_env is null)\n"
"return null;\n"
"declare _ctx any;\n"
"_ctx := deserialize (_env);\n"
"\n"
"declare _var numeric;\n"
"\n"
"_var := COVAR_POP_FIN (_env);\n"
"if (_var is null)\n"
"return null;\n"
"return aref (_ctx,0) * _var;\n"
"}\n"
"--src useraggr.sql:668\n";

static const char *other16 = 
"create aggregate DB.DBA.REGR_SXX (in e1 numeric, in e2 numeric) returns numeric from\n"
"STD12_INIT, REGR_SXX_ACC, REGR_S___FIN\n";

static const char *other17 = 
"create aggregate DB.DBA.REGR_SYY (in e1 numeric, in e2 numeric) returns numeric from\n"
"STD12_INIT, REGR_SYY_ACC, REGR_S___FIN\n";

static const char *other18 = 
"create aggregate DB.DBA.REGR_SXY (in e1 numeric, in e2 numeric) returns numeric from\n"
"STD13_INIT, REGR_SXY_ACC, REGR_SXY_FIN\n";

static const char *proc39 = 
"#line 699 \"[executable]/useraggr.sql\"\n"
" create procedure xte_nodebld_final_root (in acc any) returns any\n"
"{\n"
"return xte_nodebld_xmlagg_final (acc, xte_head (UNAME\' root\'));\n"
"}\n"
"--src useraggr.sql:697\n";

static const char *other19 = 
"create aggregate DB.DBA.XMLAGG (in _child any) returns any\n"
"from xte_nodebld_init, xte_nodebld_xmlagg_acc, xte_nodebld_final_root\n";

static const char *other20 = 
"create aggregate DB.DBA.VECTOR_AGG (in _child any) returns any\n"
"from vectorbld_init, vectorbld_agg_acc, vectorbld_agg_final\n"
"order\n";

static const char *other21 = 
"create aggregate DB.DBA.VECTOR_OF_NONNULLS_AGG (in _child any) returns any\n"
"from vectorbld_init, vector_of_nonnulls_bld_agg_acc, vectorbld_agg_final\n"
"order\n";

static const char *other22 = 
"create aggregate DB.DBA.VECTOR_OR_NULL_AGG (in _child any) returns any\n"
"from vectorbld_init, vectorbld_agg_acc, vector_or_null_bld_agg_final\n"
"order\n";

static const char *other23 = 
"create aggregate DB.DBA.VECTOR_OF_NONNULLS_OR_NULL_AGG (in _child any) returns any\n"
"from vectorbld_init, vector_of_nonnulls_bld_agg_acc, vector_or_null_bld_agg_final\n"
"order\n";

static const char *other24 = 
"create aggregate DB.DBA.VECTOR_CONCAT_AGG (in _child any) returns any\n"
"from vectorbld_init, vectorbld_concat_agg_acc, vectorbld_agg_final\n"
"order\n";

static const char *other25 = 
"create aggregate DB.DBA.XQ_SEQUENCE_AGG (in _child any) returns any\n"
"from xq_sequencebld_init, xq_sequencebld_agg_acc, xq_sequencebld_agg_final\n"
"order\n";

static const char *other26 = 
"create aggregate DB.DBA.BAG_AGG (in _child any) returns any\n"
"from vectorbld_init, vectorbld_agg_acc, vectorbld_agg_final\n";

static const char *other27 = 
"create aggregate DB.DBA.BAG_OF_NONNULLS_AGG (in _child any) returns any\n"
"from vectorbld_init, vector_of_nonnulls_bld_agg_acc, vectorbld_agg_final\n";

static const char *other28 = 
"create aggregate DB.DBA.BAG_OR_NULL_AGG (in _child any) returns any\n"
"from vectorbld_init, vectorbld_agg_acc, vector_or_null_bld_agg_final\n";

static const char *other29 = 
"create aggregate DB.DBA.BAG_OF_NONNULLS_OR_NULL_AGG (in _child any) returns any\n"
"from vectorbld_init, vector_of_nonnulls_bld_agg_acc, vector_or_null_bld_agg_final\n";

static const char *other30 = 
"create aggregate DB.DBA.BAG_CONCAT_AGG (in _child any) returns any\n"
"from vectorbld_init, vectorbld_concat_agg_acc, vectorbld_agg_final\n";

static const char *proc40 = 
"#line 762 \"[executable]/useraggr.sql\"\n"
" create procedure DB.DBA.GROUP_CONCAT_INIT (inout _env any)\n"
"{\n"
"_env := 0;\n"
"}\n"
"--src useraggr.sql:760\n";

static const char *proc41 = 
"#line 769 \"[executable]/useraggr.sql\"\n"
" create procedure DB.DBA.GROUP_CONCAT_ACC (inout _env any, in token varchar, in delim varchar)\n"
"{\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"if (__tag of varchar <> __tag (_env))\n"
"_env := cast (token as varchar);\n"
"else if (delim is not null)\n"
"_env := concat (_env, cast (delim as varchar), cast (token as varchar));\n"
"else\n"
"_env := concat (_env, cast (token as varchar));\n"
"}\n"
"--src useraggr.sql:767\n";

static const char *proc42 = 
"#line 786 \"[executable]/useraggr.sql\"\n"
" create procedure DB.DBA.GROUP_CONCAT_FIN (inout _env any)\n"
"{\n"
"\n"
"\n"
"\n"
"if (__tag of varchar <> __tag (_env))\n"
"return \'\';\n"
"return _env;\n"
"}\n"
"--src useraggr.sql:784\n";

static const char *other31 = 
"create aggregate DB.DBA.GROUP_CONCAT (in token varchar, in delim varchar) returns varchar\n"
"from DB.DBA.GROUP_CONCAT_INIT, DB.DBA.GROUP_CONCAT_ACC, DB.DBA.GROUP_CONCAT_FIN\n"
"order\n";

static const char *proc43 = 
"#line 804 \"[executable]/useraggr.sql\"\n"
" create procedure DB.DBA.GROUP_DIGEST_INIT (inout _env any)\n"
"{\n"
"_env := 0;\n"
"}\n"
"--src useraggr.sql:802\n";

static const char *proc44 = 
"#line 811 \"[executable]/useraggr.sql\"\n"
" create procedure DB.DBA.GROUP_DIGEST_ACC (inout _env any, in token varchar, in delim varchar, in maxlen integer, in mode integer)\n"
"{\n"
"declare curlen integer;\n"
"declare env_vec, items any;\n"
"if (__tag of varchar <> __tag (token))\n"
"{\n"
"token := cast (token as varchar);\n"
"if (token is null)\n"
"return;\n"
"}\n"
"if (__tag of varchar <> __tag (_env))\n"
"{\n"
"if (length (token) > maxlen)\n"
"token := subseq (token, 0, maxlen+1);\n"
"_env := serialize (vector_zap_args (vector_zap_args (token), cast (delim as varchar), maxlen));\n"
"return;\n"
"}\n"
"curlen := length (_env);\n"
"if (curlen >= maxlen)\n"
"return;\n"
"env_vec := deserialize (_env);\n"
"items := aref_set_0 (env_vec, 0);\n"
"if (bit_and (mode, 1))\n"
"{\n"
"if (0 < position (token, items))\n"
"return;\n"
"}\n"
"if (length (token) > (env_vec[2] - curlen))\n"
"token := subseq (token, 0, (env_vec[2] - curlen)+1);\n"
"items := vector_concat (items, vector_zap_args (token));\n"
"aset_zap_arg (env_vec, 0, items);\n"
"_env := serialize (env_vec);\n"
"}\n"
"--src useraggr.sql:809\n";

static const char *proc45 = 
"#line 847 \"[executable]/useraggr.sql\"\n"
" create procedure DB.DBA.GROUP_DIGEST_FIN (inout _env any)\n"
"{\n"
"declare envlen, curlen, maxlen, itemctr, itemcount, delim_len, rest_len integer;\n"
"declare env_vec, items, ses any;\n"
"declare delim varchar;\n"
"if (__tag of varchar <> __tag (_env))\n"
"return \'\';\n"
"envlen := length (_env);\n"
"env_vec := deserialize (_env);\n"
"items := aref_set_0 (env_vec, 0);\n"
"delim := aref_set_0 (env_vec, 1);\n"
"rest_len := maxlen := aref_set_0 (env_vec, 2);\n"
"ses := string_output ();\n"
"itemctr := 0;\n"
"itemcount := length (items);\n"
"delim_len := length (delim);\n"
"for (itemctr := 0; itemctr < itemcount; itemctr := itemctr + 1)\n"
"{\n"
"declare itm varchar;\n"
"declare itm_len integer;\n"
"if (delim_len > (rest_len-5))\n"
"goto items_done;\n"
"if (itemctr)\n"
"{\n"
"http (delim, ses);\n"
"rest_len := rest_len - delim_len;\n"
"}\n"
"itm := items [itemctr];\n"
"itm_len := length (itm);\n"
"if ((itm_len > rest_len) or ((envlen > maxlen) and (itemctr = itemcount-1)))\n"
"{\n"
"itm := subseq (itm, 0, rest_len);\n"
"itm_len := coalesce (__max_notnull (strrchr (itm, 32), strrchr (itm, 10), strrchr (itm, 13)), 0);\n"
"while ((itm_len > 0) and (itm [itm_len-1] in (32, 10, 13)))\n"
"itm_len := itm_len - 1;\n"
"if (0 = itm_len)\n"
"http (subseq (itm, 0, rest_len-3), ses);\n"
"else\n"
"http (subseq (itm, 0, itm_len), ses);\n"
"http (\'...\', ses);\n"
"goto items_done;\n"
"}\n"
"http (itm, ses);\n"
"rest_len := rest_len - itm_len;\n"
"}\n"
"items_done:\n"
"return string_output_string (ses);\n"
"}\n"
"--src useraggr.sql:845\n";

static const char *other32 = 
"create aggregate DB.DBA.GROUP_DIGEST (in token varchar, in delim varchar, in maxlen integer, in mode integer) returns varchar\n"
"from DB.DBA.GROUP_DIGEST_INIT, DB.DBA.GROUP_DIGEST_ACC, DB.DBA.GROUP_DIGEST_FIN\n"
"order\n";

static const char *proc46 = 
"#line 904 \"[executable]/useraggr.sql\"\n"
" create procedure DB.DBA.SAMPLE_INIT (inout _env any)\n"
"{\n"
"_env := null;\n"
"}\n"
"--src useraggr.sql:902\n";

static const char *proc47 = 
"#line 911 \"[executable]/useraggr.sql\"\n"
" create procedure DB.DBA.SAMPLE_ACC (inout _env any, in sample any)\n"
"{\n"
"if (_env is not null)\n"
"return;\n"
"_env := sample;\n"
"}\n"
"--src useraggr.sql:909\n";

static const char *proc48 = 
"#line 920 \"[executable]/useraggr.sql\"\n"
" create procedure DB.DBA.SAMPLE_FIN (inout _env any)\n"
"{\n"
"return _env;\n"
"}\n"
"--src useraggr.sql:918\n";

static const char *other33 = 
"create aggregate DB.DBA.SAMPLE (in sample any) returns any\n"
"from DB.DBA.SAMPLE_INIT, DB.DBA.SAMPLE_ACC, DB.DBA.SAMPLE_FIN\n"
"order\n";

/* sparql_init.sql */

static const char *proc49 = 
"#line 24 \"[executable]/sparql_init.sql\"\n"
"create function DB.DBA.RDF_LANGUAGE_OF_LONG (in longobj any, in dflt varchar := \'\') returns any\n"
"{\n"
"if (__tag of rdf_box = __tag (longobj))\n"
"{\n"
"declare twobyte integer;\n"
"declare res varchar;\n"
"twobyte := rdf_box_lang (longobj);\n"
"if (257 = twobyte)\n"
"return dflt;\n"
"whenever not found goto badlang;\n"
"select lower (RL_ID) into res from DB.DBA.RDF_LANGUAGE where RL_TWOBYTE = twobyte;\n"
"return res;\n"
"\n"
"badlang:\n"
"signal (\'RDFXX\', sprintf (\'Unknown language in DB.DBA.RDF_LANGUAGE_OF_LONG, bad id %d\', twobyte));\n"
"}\n"
"return case (isiri_id (longobj)) when 0 then dflt else null end;\n"
"}\n"
"--src sparql_init.sql:22\n";

static const char *proc50 = 
"#line 47 \"[executable]/sparql_init.sql\"\n"
"create function DB.DBA.JSO_MAKE_INHERITANCE (in jgraph varchar, in class varchar, in rootinst varchar, in destinst varchar, in dest_iid iri_id, inout noinherits any, inout inh_stack any)\n"
"{\n"
"declare base_iid iri_id;\n"
"declare baseinst varchar;\n"
"\n"
"inh_stack := vector_concat (inh_stack, vector (destinst));\n"
"baseinst := null;\n"
"if (not exists (sparql\n"
"define input:storage \"\"\n"
"prefix virtrdf: <http://www.openlinksw.com/schemas/virtrdf#>\n"
"ask where {\n"
"graph ?:jgraph { ?:dest_iid rdf:type `iri(?:class)`\n"
"} } ) )\n"
"signal (\'22023\', \'JSO_MAKE_INHERITANCE has not found object <\' || destinst || \'> of type <\' || class || \'>\');\n"
"/* This fails. !!!TBD: fix sparql2sql.c to preserve data about equalities, fixed values and globals when triples are moved from gp to gp\n"
"for (sparql\n"
"define input:storage \"\"\n"
"prefix virtrdf: <http://www.openlinksw.com/schemas/virtrdf#>\n"
"select ?srcinst\n"
"where {\n"
"graph ?:jgraph {\n"
"{ {\n"
"?destnode rdf:type `iri(?:class)` .\n"
"filter (?destnode = iri(?:destinst)) }\n"
"union\n"
"{\n"
"?destnode rdf:type `iri(?:class)` .\n"
"?destnode rdf:name `iri(?:destinst)` } } .\n"
"?destnode virtrdf:inheritFrom ?srcinst .\n"
"?srcinst rdf:type `iri(?:class)` .\n"
"} } ) do\n"
"*/\n"
"for (sparql\n"
"define input:storage \"\"\n"
"define output:valmode \"LONG\"\n"
"prefix virtrdf: <http://www.openlinksw.com/schemas/virtrdf#>\n"
"select ?src_iid\n"
"where {\n"
"graph ?:jgraph { ?:dest_iid virtrdf:inheritFrom ?src_iid } } ) do\n"
"{\n"
"declare srcinst varchar;\n"
"srcinst := id_to_iri_nosignal (\"src_iid\");\n"
"if (baseinst is null)\n"
"{\n"
"if (not exists (sparql\n"
"define input:storage \"\"\n"
"prefix virtrdf: <http://www.openlinksw.com/schemas/virtrdf#>\n"
"ask where { graph ?:jgraph { ?:\"src_iid\" rdf:type `iri(?:class)` } } ) )\n"
"signal (\'22023\', \'JSO_MAKE_INHERITANCE has found that the object <\' || destinst || \'> has wrong virtrdf:inheritFrom <\' || srcinst || \'> that is not an instance of type <\' || class || \'>\');\n"
"base_iid := \"src_iid\";\n"
"baseinst := srcinst;\n"
"}\n"
"else if (baseinst <> srcinst)\n"
"signal (\'22023\', \'JSO_MAKE_INHERITANCE has found that the object <\' || destinst || \'> has multiple virtrdf:inheritFrom declarations: <\' || baseinst || \'> and <\' || srcinst || \'>\');\n"
"}\n"
"if (position (baseinst, inh_stack))\n"
"signal (\'22023\', \'JSO_MAKE_INHERITANCE has found that the object <\' || baseinst || \'> is recursively inherited from itself\');\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"for (sparql\n"
"define input:storage \"\"\n"
"prefix virtrdf: <http://www.openlinksw.com/schemas/virtrdf#>\n"
"select ?pred\n"
"where {\n"
"graph ?:jgraph {\n"
"?:dest_iid virtrdf:noInherit ?pred\n"
"} } ) do\n"
"{\n"
"if (baseinst is null)\n"
"signal (\'22023\', \'JSO_MAKE_INHERITANCE has found that the object <\' || destinst || \'> has set virtrdf:noInherit but has no virtrdf:inheritFrom\');\n"
"dict_put (noinherits, \"pred\", destinst);\n"
"}\n"
"if (baseinst is null)\n"
"return;\n"
"for (select \"pred_id\", \"predval\"\n"
"from (sparql\n"
"define input:storage \"\"\n"
"define output:valmode \"LONG\"\n"
"prefix virtrdf: <http://www.openlinksw.com/schemas/virtrdf#>\n"
"select ?pred_id, ?predval\n"
"where {\n"
"graph ?:jgraph {\n"
"?:base_iid ?pred_id ?predval\n"
"} } ) as \"t00\"\n"
"where not exists (sparql\n"
"define input:storage \"\"\n"
"prefix virtrdf: <http://www.openlinksw.com/schemas/virtrdf#>\n"
"ask where { graph ?:jgraph { ?:\"t00\".\"pred_id\" virtrdf:loadAs virtrdf:jsoTriple } } )\n"
") do\n"
"{\n"
"declare \"pred\" any;\n"
"\"pred\" := id_to_iri (\"pred_id\");\n"
"if (DB.DBA.RDF_LANGUAGE_OF_LONG (\"predval\", null) is not null)\n"
"signal (\'22023\', \'JSO_MAKE_INHERITANCE does not support language marks on objects\');\n"
"if (\'http://www.w3.org/1999/02/22-rdf-syntax-ns#type\' = \"pred\")\n"
" ;\n"
"else if (\'http://www.w3.org/1999/02/22-rdf-syntax-ns#name\' = \"pred\")\n"
" ;\n"
"else if (\'http://www.openlinksw.com/schemas/virtrdf#inheritFrom\' = \"pred\")\n"
" ;\n"
"else if (\'http://www.openlinksw.com/schemas/virtrdf#noInherit\' = \"pred\")\n"
" ;\n"
"else if (dict_get (noinherits, \"pred\", baseinst) = baseinst)\n"
"{\n"
"jso_set (class, rootinst, \"pred\", __rdf_sqlval_of_obj (\"predval\"), isiri_id (\"predval\"));\n"
"dict_put (noinherits, \"pred\", baseinst);\n"
"}\n"
"}\n"
"DB.DBA.JSO_MAKE_INHERITANCE (jgraph, class, rootinst, baseinst, base_iid, noinherits, inh_stack);\n"
"}\n"
"--src sparql_init.sql:45\n";

static const char *proc51 = 
"#line 173 \"[executable]/sparql_init.sql\"\n"
"create function DB.DBA.JSO_LOAD_INSTANCE (in jgraph varchar, in jinst varchar, in delete_first integer, in make_new integer, in jsubj_iid iri_id := 0)\n"
"{\n"
"declare jinst_iid, jgraph_iid IRI_ID;\n"
"declare jclass varchar;\n"
"declare noinherits, inh_stack, \"p\" any;\n"
"\n"
"noinherits := dict_new ();\n"
"jinst_iid := iri_ensure (jinst);\n"
"jgraph_iid := iri_ensure (jgraph);\n"
"if (jsubj_iid is null)\n"
"{\n"
"jsubj_iid := (sparql\n"
"define input:storage \"\"\n"
"define output:valmode \"LONG\"\n"
"select ?s\n"
"where { graph ?:jgraph { ?s rdf:name ?:jinst } } );\n"
"if (jsubj_iid is null)\n"
"jsubj_iid := jinst_iid;\n"
"}\n"
"jclass := (sparql\n"
"define input:storage \"\"\n"
"select ?t\n"
"where {\n"
"graph ?:jgraph { ?:jsubj_iid rdf:type ?t } } );\n"
"if (jclass is null)\n"
"{\n"
"if (exists (sparql\n"
"define input:storage \"\"\n"
"select ?x\n"
"where { graph ?:jgraph {\n"
"{ ?:jinst ?x ?o }\n"
"union\n"
"{ ?x rdf:name ?ji .\n"
"filter (str (?ji) = ?:jinst)\n"
"} } } ) )\n"
"signal (\'22023\', \'JSO_LOAD_INSTANCE can not detect the type of <\' || jinst || \'>\');\n"
"else\n"
"signal (\'22023\', \'JSO_LOAD_INSTANCE can not find an object <\' || jinst || \'>\');\n"
"}\n"
"if (delete_first)\n"
"jso_delete (jclass, jinst, 1);\n"
"if (make_new)\n"
"jso_new (jclass, jinst);\n"
"for (select \"p_id\", coalesce (\"o2\", \"o1\") as \"o\"\n"
"from (sparql\n"
"define input:storage \"\"\n"
"define output:valmode \"LONG\"\n"
"select ?p_id ?o1 ?o2\n"
"where {\n"
"graph ?:jgraph {\n"
"{ ?:jsubj_iid ?p_id ?o1 }  optional { ?o1 rdf:name ?o2 }\n"
"} }\n"
") as \"t00\"\n"
"where not exists (sparql\n"
"define input:storage \"\"\n"
"prefix virtrdf: <http://www.openlinksw.com/schemas/virtrdf#>\n"
"ask where { graph ?:jgraph_iid { ?:\"t00\".\"p_id\" virtrdf:loadAs virtrdf:jsoTriple } } ) option (quietcast)\n"
") do\n"
"{\n"
"\"p\" := id_to_iri (\"p_id\");\n"
"if (DB.DBA.RDF_LANGUAGE_OF_LONG (\"o\", null) is not null)\n"
"signal (\'22023\', \'JSO_LOAD_INSTANCE does not support language marks on objects\');\n"
"if (\'http://www.w3.org/1999/02/22-rdf-syntax-ns#type\' = \"p\")\n"
"{\n"
"if (__rdf_sqlval_of_obj (\"o\") <> jclass)\n"
"signal (\'22023\', \'JSO_LOAD_INSTANCE has found that the object <\' || jinst || \'> has multiple type declarations\');\n"
"}\n"
"else if (\'http://www.w3.org/1999/02/22-rdf-syntax-ns#name\' = \"p\")\n"
" ;\n"
"else if (\'http://www.openlinksw.com/schemas/virtrdf#inheritFrom\' = \"p\")\n"
" ;\n"
"else if (\'http://www.openlinksw.com/schemas/virtrdf#noInherit\' = \"p\")\n"
" ;\n"
"else\n"
"{\n"
"jso_set (jclass, jinst, \"p\", __rdf_sqlval_of_obj (\"o\"), isiri_id (\"o\"));\n"
"dict_put (noinherits, \"p\", jinst);\n"
"}\n"
"}\n"
"inh_stack := vector ();\n"
"DB.DBA.JSO_MAKE_INHERITANCE (jgraph, jclass, jinst, jinst, jsubj_iid, noinherits, inh_stack);\n"
"}\n"
"--src sparql_init.sql:171\n";

static const char *proc52 = 
"#line 257 \"[executable]/sparql_init.sql\"\n"
"create procedure DB.DBA.JSO_LIST_INSTANCES_OF_GRAPH (in jgraph varchar, out instances any)\n"
"{\n"
"declare md, res, st, msg any;\n"
"st:= \'00000\';\n"
"exec (\n"
"\'select DB.DBA.VECTOR_AGG (\n"
"vector (\n"
"id_to_iri (\"jclass\"),\n"
"id_to_iri (\"jinst\"),\n"
"coalesce (\"s\", \"jinst\") ) )\n"
"from ( sparql\n"
"define output:valmode \"LONG\"\n"
"define input:storage \"\"\n"
"select ?jclass ?jinst ?s\n"
"where {\n"
"graph ?? {\n"
"{ ?jinst rdf:type ?jclass .\n"
"filter (!isBLANK (?jinst)) }\n"
"union\n"
"{ ?s rdf:type ?jclass .\n"
"?s rdf:name ?jinst .\n"
"filter (isBLANK (?s))\n"
"} } }\n"
") as inst\',\n"
"st, msg, vector (jgraph), 1, md, res);\n"
"if (st <> \'00000\') signal (st, msg);\n"
"instances := res[0][0];\n"
"}\n"
"--src sparql_init.sql:255\n";

static const char *proc53 = 
"#line 287 \"[executable]/sparql_init.sql\"\n"
"create function DB.DBA.JSO_LOAD_GRAPH (in jgraph varchar, in pin_now integer := 1)\n"
"{\n"
"declare jgraph_iid IRI_ID;\n"
"declare instances, chk any;\n"
"\n"
"log_text (\'DB.DBA.JSO_LOAD_GRAPH (?,?)\', jgraph, pin_now);\n"
"jgraph_iid := iri_ensure (jgraph);\n"
"DB.DBA.JSO_LIST_INSTANCES_OF_GRAPH (jgraph, instances);\n"
"/* Pass 1. Deleting all obsolete instances. */\n"
"foreach (any j in instances) do\n"
"jso_delete (j[0], j[1], 1);\n"
"/* Pass 2. Creating all instances. */\n"
"foreach (any j in instances) do\n"
"jso_new (j[0], j[1]);\n"
"/* Pass 3. Loading all instances, including loading inherited values. */\n"
"foreach (any j in instances) do\n"
"DB.DBA.JSO_LOAD_INSTANCE (jgraph, j[1], 0, 0, j[2]);\n"
"/* Pass 4. Validation all instances. */\n"
"foreach (any j in instances) do\n"
"jso_validate (j[0], j[1], 1);\n"
"/* Pass 5. Pin all instances. */\n"
"if (pin_now)\n"
"{\n"
"foreach (any j in instances) do\n"
"jso_pin (j[0], j[1]);\n"
"}\n"
"/* Pass 6. Load all separate triples */\n"
"exec (\'sparql\n"
"define input:storage \"\"\n"
"define sql:table-option \"LOOP\"\n"
"prefix virtrdf: <http://www.openlinksw.com/schemas/virtrdf#>\n"
"select (bif:jso_triple_add (?s, ?p, ?o))\n"
"where { graph <\' || id_to_iri (jgraph_iid) || \'> { ?p virtrdf:loadAs virtrdf:jsoTriple . ?s ?p ?o } }\');\n"
"chk := jso_triple_get_objs (\n"
"UNAME\'http://www.openlinksw.com/schemas/virtrdf#loadAs\',\n"
"UNAME\'http://www.openlinksw.com/schemas/virtrdf#loadAs\' );\n"
"if ((1 <> length (chk)) or (cast (chk[0] as varchar) <> \'http://www.openlinksw.com/schemas/virtrdf#jsoTriple\'))\n"
"signal (\'22023\', \'JSO_LOAD_GRAPH has not found expected metadata in the graph\');\n"
"}\n"
"--src sparql_init.sql:285\n";

static const char *proc54 = 
"#line 328 \"[executable]/sparql_init.sql\"\n"
"create function DB.DBA.JSO_PIN_GRAPH (in jgraph varchar)\n"
"{\n"
"declare instances any;\n"
"log_text (\'DB.DBA.JSO_PIN_GRAPH (?)\', jgraph);\n"
"DB.DBA.JSO_LIST_INSTANCES_OF_GRAPH (jgraph, instances);\n"
"foreach (any j in instances) do\n"
"jso_pin (j[0], j[1]);\n"
"}\n"
"--src sparql_init.sql:326\n";

static const char *proc55 = 
"#line 339 \"[executable]/sparql_init.sql\"\n"
" create function DB.DBA.JSO_SYS_GRAPH () returns varchar\n"
"{\n"
"return \'http://www.openlinksw.com/schemas/virtrdf#\';\n"
"}\n"
"--src sparql_init.sql:337\n";

static const char *proc56 = 
"#line 346 \"[executable]/sparql_init.sql\"\n"
"create procedure DB.DBA.JSO_LOAD_AND_PIN_SYS_GRAPH_RO (in graphiri varchar := null)\n"
"{\n"
"if (graphiri is null)\n"
"graphiri := DB.DBA.JSO_SYS_GRAPH();\n"
"if (not exists (select 1 from SYS_KEYS where KEY_TABLE = \'DB.DBA.RDF_QUAD\'))\n"
"return;\n"
"DB.DBA.JSO_LOAD_GRAPH (graphiri, 0);\n"
"DB.DBA.JSO_PIN_GRAPH (graphiri);\n"
"}\n"
"--src sparql_init.sql:344\n";

static const char *proc57 = 
"#line 357 \"[executable]/sparql_init.sql\"\n"
"create procedure DB.DBA.RDF_INIT_SINGLE_SERVER ()\n"
"{\n"
"if (1 <> sys_stat (\'cl_run_local_only\'))\n"
"return;\n"
"DB.DBA.JSO_LOAD_AND_PIN_SYS_GRAPH_RO ();\n"
"}\n"
"--src sparql_init.sql:355\n";

static const char *other34 = 
"DB.DBA.RDF_INIT_SINGLE_SERVER ()\n";
static int
sch_proc_def_exists (client_connection_t *cli, const char *proc_name, const int report)
{
  query_t *proc = NULL;
  char *full_name = sch_full_proc_name (isp_schema(NULL), proc_name,
	cli->cli_qualifier, CLI_OWNER (cli));
  if (full_name)
    proc = sch_proc_def (isp_schema(NULL), full_name);
  if (report && proc != NULL)
     log_debug ("built-in procedure \"%s\" overruled by the RDBMS", proc_name);
  return (proc != NULL);
}

#define DEFINE_PROC(name, proc) \
   if (!sch_proc_def_exists (bootstrap_cli, (name), log_proc_overwrite)) \
     ddl_std_proc_1 (proc, 0x0, 1)


#define DEFINE_PUBLIC_PROC(name, proc) \
   if (!sch_proc_def_exists (bootstrap_cli, (name), log_proc_overwrite)) \
     ddl_std_proc_1 (proc, 0x1, 1)


#define DEFINE_OVERWRITE_PROC(name, proc) \
   ddl_std_proc_1 (proc, 0x1, 1)


void
sqls_define_sparql_init (void)
{
  /* useraggr.sql */
 
  DEFINE_PUBLIC_PROC ("STD_COUNT", proc0); 
  DEFINE_PUBLIC_PROC ("STD11_INIT", proc1); 
  DEFINE_PUBLIC_PROC ("STD12_INIT", proc2); 
  DEFINE_PUBLIC_PROC ("STD13_INIT", proc3); 
  DEFINE_PUBLIC_PROC ("VAR_ACC", proc4); 
  DEFINE_PUBLIC_PROC ("VAR_POP_FIN", proc5); 
  DEFINE_PUBLIC_PROC ("VAR_SAMP_FIN", proc6); 
  DEFINE_PUBLIC_PROC ("VAR_FIN", proc7); 
  DEFINE_PUBLIC_PROC ("STDDEV_POP_FIN", proc8); 
  DEFINE_PUBLIC_PROC ("STDDEV_SAMP_FIN", proc9); 
  DEFINE_PUBLIC_PROC ("STDDEV_FIN", proc10); 
  DEFINE_PUBLIC_PROC ("COVAR_ACC", proc11); 
  DEFINE_PUBLIC_PROC ("COVAR_SAMP_FIN", proc12); 
  DEFINE_PUBLIC_PROC ("COVAR_POP_FIN", proc13); 
  DEFINE_PUBLIC_PROC ("COVAR_FIN", proc14);
  ddl_ensure_table ("do this always", other0);
  ddl_ensure_table ("do this always", other1);
  ddl_ensure_table ("do this always", other2);
  ddl_ensure_table ("do this always", other3);
  ddl_ensure_table ("do this always", other4);
  ddl_ensure_table ("do this always", other5);
  ddl_ensure_table ("do this always", other6);
  ddl_ensure_table ("do this always", other7);
  ddl_ensure_table ("do this always", other8); 
  DEFINE_PUBLIC_PROC ("REGR_SLOPE_INIT", proc15); 
  DEFINE_PUBLIC_PROC ("REGR_SLOPE_ACC", proc16); 
  DEFINE_PUBLIC_PROC ("REGR_SLOPE_FIN", proc17);
  ddl_ensure_table ("do this always", other9); 
  DEFINE_PUBLIC_PROC ("REGR_INTERCEPT_INIT", proc18); 
  DEFINE_PUBLIC_PROC ("REGR_INTERCEPT_ACC", proc19); 
  DEFINE_PUBLIC_PROC ("REGR_INTERCEPT_FIN", proc20);
  ddl_ensure_table ("do this always", other10); 
  DEFINE_PUBLIC_PROC ("REGR_COUNT_INIT", proc21); 
  DEFINE_PUBLIC_PROC ("REGR_COUNT_ACC", proc22); 
  DEFINE_PUBLIC_PROC ("REGR_COUNT_FIN", proc23); 
  DEFINE_PUBLIC_PROC ("REGR_COUNT_MERGE", proc24);
  ddl_ensure_table ("do this always", other11); 
  DEFINE_PUBLIC_PROC ("REGR_AVG_ACC", proc25); 
  DEFINE_PUBLIC_PROC ("REGR_AVGX_FIN", proc26); 
  DEFINE_PUBLIC_PROC ("REGR_AVGY_FIN", proc27);
  ddl_ensure_table ("do this always", other12);
  ddl_ensure_table ("do this always", other13); 
  DEFINE_PUBLIC_PROC ("CORR_INIT", proc28); 
  DEFINE_PUBLIC_PROC ("CORR_ACC", proc29); 
  DEFINE_PUBLIC_PROC ("CORR_FIN", proc30);
  ddl_ensure_table ("do this always", other14); 
  DEFINE_PUBLIC_PROC ("REGR_R2_INIT", proc31); 
  DEFINE_PUBLIC_PROC ("REGR_R2_ACC", proc32); 
  DEFINE_PUBLIC_PROC ("REGR_R2_FIN", proc33);
  ddl_ensure_table ("do this always", other15); 
  DEFINE_PUBLIC_PROC ("REGR_SXX_ACC", proc34); 
  DEFINE_PUBLIC_PROC ("REGR_SYY_ACC", proc35); 
  DEFINE_PUBLIC_PROC ("REGR_SXY_ACC", proc36); 
  DEFINE_PUBLIC_PROC ("REGR_S___FIN", proc37); 
  DEFINE_PUBLIC_PROC ("REGR_SXY_FIN", proc38);
  ddl_ensure_table ("do this always", other16);
  ddl_ensure_table ("do this always", other17);
  ddl_ensure_table ("do this always", other18); 
  DEFINE_PUBLIC_PROC ("xte_nodebld_final_root", proc39);
  ddl_ensure_table ("do this always", other19);
  ddl_ensure_table ("do this always", other20);
  ddl_ensure_table ("do this always", other21);
  ddl_ensure_table ("do this always", other22);
  ddl_ensure_table ("do this always", other23);
  ddl_ensure_table ("do this always", other24);
  ddl_ensure_table ("do this always", other25);
  ddl_ensure_table ("do this always", other26);
  ddl_ensure_table ("do this always", other27);
  ddl_ensure_table ("do this always", other28);
  ddl_ensure_table ("do this always", other29);
  ddl_ensure_table ("do this always", other30); 
  DEFINE_PUBLIC_PROC ("DB.DBA.GROUP_CONCAT_INIT", proc40); 
  DEFINE_PUBLIC_PROC ("DB.DBA.GROUP_CONCAT_ACC", proc41); 
  DEFINE_PUBLIC_PROC ("DB.DBA.GROUP_CONCAT_FIN", proc42);
  ddl_ensure_table ("do this always", other31); 
  DEFINE_PUBLIC_PROC ("DB.DBA.GROUP_DIGEST_INIT", proc43); 
  DEFINE_PUBLIC_PROC ("DB.DBA.GROUP_DIGEST_ACC", proc44); 
  DEFINE_PUBLIC_PROC ("DB.DBA.GROUP_DIGEST_FIN", proc45);
  ddl_ensure_table ("do this always", other32); 
  DEFINE_PUBLIC_PROC ("DB.DBA.SAMPLE_INIT", proc46); 
  DEFINE_PUBLIC_PROC ("DB.DBA.SAMPLE_ACC", proc47); 
  DEFINE_PUBLIC_PROC ("DB.DBA.SAMPLE_FIN", proc48);
  ddl_ensure_table ("do this always", other33);

  /* sparql_init.sql */

  DEFINE_PROC ("DB.DBA.RDF_LANGUAGE_OF_LONG", proc49);
  DEFINE_PROC ("DB.DBA.JSO_MAKE_INHERITANCE", proc50);
  DEFINE_PROC ("DB.DBA.JSO_LOAD_INSTANCE", proc51);
  DEFINE_PROC ("DB.DBA.JSO_LIST_INSTANCES_OF_GRAPH", proc52);
  DEFINE_PROC ("DB.DBA.JSO_LOAD_GRAPH", proc53);
  DEFINE_PROC ("DB.DBA.JSO_PIN_GRAPH", proc54); 
  DEFINE_PUBLIC_PROC ("DB.DBA.JSO_SYS_GRAPH", proc55);
  DEFINE_PROC ("DB.DBA.JSO_LOAD_AND_PIN_SYS_GRAPH_RO", proc56);
  DEFINE_PROC ("DB.DBA.RDF_INIT_SINGLE_SERVER", proc57);
  ddl_ensure_table ("do this always", other34);
}


void
sqls_arfw_define_sparql_init (void)
{
}
